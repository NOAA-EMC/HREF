#!/bin/ksh
################################################################################
####  UNIX Script Documentation Block
#                      .                                             .
# Script name:         exhiresw_vinterp.sh.ecf
# Script description:  Final step to generate  WRF Preprocessing System (WPS) and REAL code for the WRF-NMM and 
#                      WRF-ARW model
#
# Author:        Eric Rogers       Org: NP22         Date: 2004-07-02
#
# Abstract: The script runs the WRF REAL codes (WRF-ARW) and nemsinterp (NMMB) 
#           to vertically interpolate the information provided by METGRID onto the 
#           model vertical coordinate.  The initial and lateral boundary condition
#           files needed by the forecast models also are created.
#
# Script history log:
# 2003-11-01  Matt Pyle - Original script for parallel
# 2004-07-02  Eric Rogers - Preliminary modifications for production.
# 2004-10-01  Eric Rogers - Modified to run special real executable for Alaska NMM
# 2007-04-09  Matthew Pyle - Modified to run WPS rather than wrfsi
# 2009-09-24  Shawna Cokley - Streamlines way script obtains date information -
#                             pulls from $PDY rather than copying a file to the working directory
# 2013-10-01  Matthew Pyle  - Split out from old prelim job

set -x

LENGTH=48

### NEST options are east, west, ak, hi, pr, or conus
### MODEL is arw or nmm or nmmb

msg="JOB $job FOR WRF NEST=${NEST}${MODEL}_${MEMBER} HAS BEGUN"
postmsg "$jlogfile" "$msg"

yy=`echo $PDY | cut -c1-4`
mm=`echo $PDY | cut -c5-6`
dd=`echo $PDY | cut -c7-8`

ystart=`echo $PDY | cut -c1-4`
mstart=`echo $PDY | cut -c5-6`
dstart=`echo $PDY | cut -c7-8`

start=$ystart$mstart$dstart$cyc

echo start $start

# NDATE=/u/Matthew.Pyle/ndate
NDATE=/nwprod/util/exec/ndate

end=`$NDATE 48 $start`

echo end $end

yend=`echo $end | cut -c1-4`
mend=`echo $end | cut -c5-6`
dend=`echo $end | cut -c7-8`

filt_start=`$NDATE -1 $start`

filt_ys=`echo $filt_start | cut -c1-4`
filt_ms=`echo $filt_start | cut -c5-6`
filt_ds=`echo $filt_start | cut -c7-8`
filt_hs=`echo $filt_start | cut -c9-10`

filt_ye=$ystart
filt_me=$mstart
filt_de=$dstart
filt_he=$cyc


#########################################################
# RUN REAL(ARW) OR NEMSINTERP(NMMB) PROGRAM TO 
# VERTICALLY INTERPOLATE DATA AND GENERATE MODEL
# INPUT AND BOUNDARY CONDITION FILES
#########################################################

cd $DATA

cycstart=`echo ${PDY}${cyc}`

start=$ystart$mstart$dstart

end=`$NDATE $LENGTH $cycstart`

yend=`echo $end | cut -c1-4`
mend=`echo $end | cut -c5-6`
dend=`echo $end | cut -c7-8`
hend=`echo $end | cut -c9-10`

## for large domains, special namelist.input files are required for the model
## for small domains, use the same namelist for both real and the model

if [ $NEST = "hi" -o $NEST = "guam" ] ; then
  cp $PARMhiresw/hiresw_${MODEL}_namelist.input_in_small namelist.input_in
  cp $PARMhiresw/hiresw_${MODEL}_namelist.input_in_small namelist.input_in_model
elif [ $NEST = "pr" ] ; then
  cp $PARMhiresw/hiresw_${MODEL}_namelist.input_in_newpr namelist.input_in
  cp $PARMhiresw/hiresw_${MODEL}_namelist.input_in_newpr namelist.input_in_model
elif [ $NEST = "prnew" ] ; then

if [ $MODEL = "arw" ]; then
  cp $PARMhiresw/hiresw_${MODEL}_namelist.input_in_prnew namelist.input_in
  cp $PARMhiresw/hiresw_${MODEL}_namelist.input_in_prnew namelist.input_in_model
elif [ $MODEL = "nmmb" ]; then
  cp $PARMhiresw/hiresw_prnew_${MODEL}_configure_in configure_in
fi

elif [ $NEST = "hinew" ] ; then

if [ $MODEL = "arw" ]; then
  cp $PARMhiresw/hiresw_${MODEL}_namelist.input_in_hinew namelist.input_in
  cp $PARMhiresw/hiresw_${MODEL}_namelist.input_in_hinew namelist.input_in_model
elif [ $MODEL = "nmmb" ]; then
  cp $PARMhiresw/hiresw_hinew_${MODEL}_configure_in configure_in
fi

elif [ $NEST = "guamnew" ] ; then

if [ $MODEL = "arw" ]; then
  cp $PARMhiresw/hiresw_${MODEL}_namelist.input_in_guamnew namelist.input_in
  cp $PARMhiresw/hiresw_${MODEL}_namelist.input_in_guamnew namelist.input_in_model
elif [ $MODEL = "nmmb" ]; then
  cp $PARMhiresw/hiresw_guamnew_${MODEL}_configure_in configure_in
fi

elif [ $NEST = "aknew" ] ; then

if [ $MODEL = "arw" ]; then
  cp $PARMhiresw/hiresw_${MODEL}_namelist.input_in_aknew namelist.input_in
  cp $PARMhiresw/hiresw_${MODEL}_namelist.input_in_model_aknew namelist.input_in_model
elif [ $MODEL = "nmmb" ]; then
  cp $PARMhiresw/hiresw_aknew_${MODEL}_configure_in configure_in
else
  echo BAD MODEL CHOICE FOR AKNEW DOMAIN
  exit 99
fi

elif [ $NEST = "conus" ] ; then

if [ $MODEL = "arw" ]; then
  cp $PARMhiresw/hiresw_${MODEL}_namelist.input_in_big namelist.input_in
  cp $PARMhiresw/hiresw_${MODEL}_namelist.input_in_model_big namelist.input_in_model
elif [ $MODEL = "nmmb" ]; then
  cp $PARMhiresw/hiresw_conus_${MODEL}_configure_in configure_in
else
  echo BAD MODEL CHOICE FOR CONUS DOMAIN
  exit 99
fi

elif [ $NEST = "eastnew" ] ; then

if [ $MODEL = "arw" ]; then
  cp $PARMhiresw/hiresw_${MODEL}_namelist.input_in_newbig namelist.input_in
  cp $PARMhiresw/hiresw_${MODEL}_namelist.input_in_newbig_model namelist.input_in_model
elif [ $MODEL = "nmmb" ]; then
  cp $PARMhiresw/hiresw_eastnew_${MODEL}_configure_in configure_in
else
  echo BAD MODEL CHOICE FOR EAST DOMAIN
  exit 99
fi


else
  cp $PARMhiresw/hiresw_${MODEL}_namelist.input_in namelist.input_in
  cp $PARMhiresw/hiresw_${MODEL}_namelist.input_in_model namelist.input_in_model
fi


### number of input levels depends on source model data

# if [ $NEST = "hi" -o $NEST = "hinew" -o $NEST = "east" -o $NEST = "eastnew"  -o $NEST = "west" ] ; then
# NUMLEVS=40
# elif [ $NEST = "pr"  -o $NEST = "conus"  -o $NEST = "prnew" ] ; then
# NUMLEVS=43
# elif [ $NEST = "ak" -o $NEST = "aknew" -o $NEST = "guam" -o $NEST = "guamnew" ] ; then
NUMLEVS=27
if [ $mod = "rap" ]
then
NUMLEVS=40
fi

# fi

if [ $MODEL = "nmmb" ]
then

cat  configure_in | sed s:YSTART:$ystart: | sed s:MSTART:$mstart: \
 | sed s:DSTART:$dstart: | sed s:HSTART:$cyc: > configure_file_01

cp configure_file_01 configure_file

else

cat namelist.input_in | sed s:YSTART:$ystart: | sed s:MSTART:$mstart: \
 | sed s:DSTART:$dstart: | sed s:HSTART:$cyc: | sed s:YEND:$yend: \
 | sed s:MEND:$mend:     | sed s:DEND:$dend: | sed s:HEND:$hend:  \
 | sed s:FILT_YS:${filt_ys}: | sed s:FILT_MS:${filt_ms}: | sed s:FILT_DS:${filt_ds}: \
 | sed s:FILT_HS:${filt_hs}: | sed s:FILT_YE:${filt_ye}: | sed s:FILT_ME:${filt_me}: \
 | sed s:FILT_DE:${filt_de}: | sed s:FILT_HE:${filt_he}: \
 | sed s:NUMLEV:$NUMLEVS: > namelist.input

cat namelist.input_in_model | sed s:YSTART:$ystart: | sed s:MSTART:$mstart: \
 | sed s:DSTART:$dstart: | sed s:HSTART:$cyc: | sed s:YEND:$yend: \
 | sed s:MEND:$mend:     | sed s:DEND:$dend: | sed s:HEND:$hend:  \
 | sed s:FILT_YS:${filt_ys}: | sed s:FILT_MS:${filt_ms}: | sed s:FILT_DS:${filt_ds}: \
 | sed s:FILT_HS:${filt_hs}: | sed s:FILT_YE:${filt_ye}: | sed s:FILT_ME:${filt_me}: \
 | sed s:FILT_DE:${filt_de}: | sed s:FILT_HE:${filt_he}: \
 | sed s:NUMLEV:$NUMLEVS: > namelist.input_model

fi


rm fort.*

cp $PARMhiresw/hiresw_LANDUSE.TBL LANDUSE.TBL
cp $PARMhiresw/hiresw_ETAMPNEW_DATA ETAMPNEW_DATA
cp $PARMhiresw/hiresw_ETAMPNEW_DATA micro_lookup.dat
cp $PARMhiresw/hiresw_VEGPARM.TBL VEGPARM.TBL
cp $PARMhiresw/hiresw_SOILPARM.TBL SOILPARM.TBL
cp $PARMhiresw/hiresw_GENPARM.TBL GENPARM.TBL
cp $FIXhiresw/hiresw_nmm_co2.35_hybrid_50mbtop co2.35_hybrid_50mbtop
cp $FIXhiresw/hiresw_nmm_co2.35_hybrid_50mbtop co2_trans

cp $FIXhiresw/hiresw_RRTM_DATA RRTM_DATA
cp $FIXhiresw/hiresw_tr49t67 tr49t67
cp $FIXhiresw/hiresw_tr49t85 tr49t85
cp $FIXhiresw/hiresw_tr67t85 tr67t85

if [ $MODEL != nmmb ]
then

export pgm=hiresw_${MODEL}_real
. ./prep_step

if [ $MODEL = nmm ] ; then
export FORT14="co2.35_hybrid_50mbtop"
fi

./startmsg

export MP_PGMMODEL=spmd
unset MP_CMDFILE

mpirun.lsf $EXEChiresw/hiresw_${MODEL}_real_new > $pgmout 2>&1

export err=$?

if [ $err -ne 0 ]; then
   echo EXIT FROM REAL with err $err
   mv $DATA $COMOUT/.
   ./err_chk
fi

# Copy 3 files needed to run WRF forecast to COM

cp wrfbdy_d01 $COMOUT/${NEST}${MODEL}.t${cyc}z.wrfbdy_d01
cp wrfinput_d01 $COMOUT/${NEST}${MODEL}.t${cyc}z.wrfinput_d01
cp namelist.input_model $COMOUT/${NEST}${MODEL}.t${cyc}z.namelist.input

if [ ! -f $COMOUT/${NEST}${MODEL}.t${cyc}z.wrfbdy_d01 ] || [ ! -f $COMOUT/${NEST}${MODEL}.t${cyc}z.wrfinput_d01 ]; then
   mv $DATA $COMOUT/.
   ./err_exit "WRF initial or boundary condition files missing"
fi

# Cat REAL log files and send to COM
# cat $DATA/TASKOUTPUT/0000/rsl.error.0000 $DATA/TASKOUTPUT/0000/rsl.out.0000 >  $COMOUT/${NEST}${MODEL}.t${cyc}z.real.log
cat $DATA/rsl.error.0000 $DATA/rsl.out.0000 >  $COMOUT/${NEST}${MODEL}.t${cyc}z.real.log

else # nmmb case

export MP_PGMMODEL=spmd
unset MP_CMDFILE

echo NEED TO RUN NEMSINTERP
# mpirun.lsf $EXEChiresw/hiresw_nemsinterp
cp $DATA/run_ungrib/namelist.nps .

cp $EXEChiresw/hiresw_nemsinterp .
mpirun.lsf ./hiresw_nemsinterp

err=$?

echo err from hiresw_nemsinterp $err


if [ $NEST != "guamnew" ]
then

cp input_domain_01_nemsio $COMOUT/${NEST}${MODEL}.t${cyc}z.input_domain_01_nemsio_precoldstart


# nmmb file with the land states you want

namcyc=`echo $PDY | cut -c1-8`
gespath=/nwges/prod/nam.${namcyc}
INPUT_FILE="$gespath/nam.t${cyc}z.nmm_b_restart_nemsio_anl.tm00"
INPUT_FILE_TYPE="nems"

# file with the 14 GWD spaces
WRF_BINARY_FILE="input_domain_01_nemsio"

# dont touch this
DYN_CORE="nems"

# your working directory
FIXDIR=$FIXhiresw

WORK_DIR=$DATA
cd $WORK_DIR

#----------------------------------------------------------------
# don't touch fort.81 namelist settings.
#----------------------------------------------------------------

cat > ${WORK_DIR}/fort.81 << !
 &input_state_fields
  input_file="${INPUT_FILE}"
  input_file_type="${INPUT_FILE_TYPE}"
 /
 &output_grid_specs
  specs_from_output_file=.false.
  lats_output_file="${FIXDIR}/hiresw_${NEST}${MODEL}_hpnt_latitudes.grb"
  lons_output_file="${FIXDIR}/hiresw_${NEST}${MODEL}_hpnt_longitudes.grb"
  lsmask_output_file="${FIXDIR}/hiresw_${NEST}${MODEL}_slmask.grb"
  orog_output_file="${FIXDIR}/hiresw_${NEST}${MODEL}_elevtiles.grb"
  substrate_temp_output_file="${FIXDIR}/hiresw_${NEST}${MODEL}_tbot.grb"
 /
 &optional_output_fields
  snow_free_albedo_output_file=""
  greenfrc_output_file=""
  mxsnow_alb_output_file="${FIXDIR}/hiresw_${NEST}${MODEL}_mxsnoalb.grb"
  slope_type_output_file=""
  soil_type_output_file="${FIXDIR}/hiresw_${NEST}${MODEL}_soiltiles.grb"
  veg_type_output_file="${FIXDIR}/hiresw_${NEST}${MODEL}_vegtiles.grb"
  z0_output_file=""
 /
 &soil_parameters
  soil_src_input = "statsgo"
  smclow_input  = 0.5
  smchigh_input = 3.0
  smcmax_input= 0.395, 0.421, 0.434, 0.476, 0.476, 0.439,
                0.404, 0.464, 0.465, 0.406, 0.468, 0.457,
                0.464, -9.99,  0.20, 0.421
  beta_input =  4.05,  4.26,  4.74,  5.33,  5.33,  5.25,
                6.77,  8.72,  8.17, 10.73, 10.39, 11.55,
                5.25, -9.99,  4.05,  4.26
  psis_input =  0.0350, 0.0363, 0.1413, 0.7586, 0.7586, 0.3548,
                0.1349, 0.6166, 0.2630, 0.0977, 0.3236, 0.4677,
                0.3548,  -9.99, 0.0350, 0.0363
  satdk_input = 1.7600e-4, 1.4078e-5, 5.2304e-6, 2.8089e-6, 2.8089e-6,
                3.3770e-6, 4.4518e-6, 2.0348e-6, 2.4464e-6, 7.2199e-6,
                1.3444e-6, 9.7394e-7, 3.3770e-6,     -9.99, 1.4078e-5,
                1.4078e-5
  soil_src_output = "statsgo"
  smclow_output  = 0.5
  smchigh_output = 3.0
  smcmax_output= 0.395, 0.421, 0.434, 0.476, 0.476, 0.439,
                 0.404, 0.464, 0.465, 0.406, 0.468, 0.457,
                 0.464, -9.99,  0.20, 0.421
  beta_output =  4.05,  4.26,  4.74,  5.33,  5.33,  5.25,
                 6.77,  8.72,  8.17, 10.73, 10.39, 11.55,
                 5.25, -9.99,  4.05,  4.26
  psis_output =  0.0350, 0.0363, 0.1413, 0.7586, 0.7586, 0.3548,
                 0.1349, 0.6166, 0.2630, 0.0977, 0.3236, 0.4677,
                 0.3548, -9.99,  0.0350, 0.0363
  satdk_output = 1.7600e-4, 1.4078e-5, 5.2304e-6, 2.8089e-6, 2.8089e-6,
                3.3770e-6, 4.4518e-6, 2.0348e-6, 2.4464e-6, 7.2199e-6,
                1.3444e-6, 9.7394e-7, 3.3770e-6,     -9.99, 1.4078e-5,
                1.4078e-5
 /
 &veg_parameters
  veg_src_input = "igbp"
  veg_src_output = "igbp"
  salp_output = 4.0
  snup_output = 0.080, 0.080, 0.080, 0.080, 0.080, 0.020,
                0.020, 0.060, 0.040, 0.020, 0.010, 0.020,
                0.020, 0.020, 0.013, 0.013, 0.010, 0.020,
                0.020, 0.020
 /
 &final_output
  output_file_type="${DYN_CORE}"
  output_file="${WRF_BINARY_FILE}"
 /
 &options
  landice_opt=3
 /
 &nam_options
  merge=.false.
 /
!

export pgm=hiresw_coldstart
. prep_step

./startmsg
$EXEChiresw/hiresw_coldstart >> $pgmout 2>errfile
export err=$?;err_chk

fi

cd $DATA

hrs="00 03 06 09 12 15 18 21 24 27 30 33 36 39 42 45"
for hr in $hrs
do
cp boco.00${hr} $COMOUT/${NEST}${MODEL}.t${cyc}z.boco.00${hr}
done
cp input_domain_01_nemsio $COMOUT/${NEST}${MODEL}.t${cyc}z.input_domain_01_nemsio
cp configure_file $COMOUT/${NEST}${MODEL}.t${cyc}z.configure_file
err=$?

if [ $err -ne 0 ]
then
ls -ltr
./err_exit "didnt copy over configure file"
fi


fi

msg="JOB $job FOR WRF NEST=${NEST}${MODEL}_${MEMBER} HAS COMPLETED NORMALLY"
postmsg "$jlogfile" "$msg"

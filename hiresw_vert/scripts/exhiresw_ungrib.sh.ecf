#!/bin/ksh
################################################################################
####  UNIX Script Documentation Block
#                      .                                             .
# Script name:         exhiresw_ungrib.sh.ecf
# Script description:  Runs first WRF Preprocessing System (WPS) program "ungrib"
#                      to unpack needed GRIB data for initializing HiresW runs
#
# Author:        Eric Rogers       Org: NP22         Date: 2004-07-02
#
# Abstract: The scripts gets all the input files needed for the NMMB and WRF-ARW hiresw run
#           and runs the ungrib program to prepare data to be interpolated by the subsequent
#           "metgrid" job, which is run on multiple processors
#
# Script history log:
# 2003-11-01  Matt Pyle - Original script for parallel
# 2004-07-02  Eric Rogers - Preliminary modifications for production.
# 2004-10-01  Eric Rogers - Modified to run special real executable for Alaska NMM
# 2007-04-09  Matthew Pyle - Modified to run WPS rather than wrfsi
# 2009-09-24  Shawna Cokley - Streamlines way script obtains date information -
#                             pulls from $PDY rather than copying a file to the working directory
# 2013-09-30  Matthew Pyle - Broken out from prelim job (prelim job now in three distinct pieces)

set -x

LENGTH=48

### NEST options are east, west, ak, hi, pr, or conus
### MODEL is arw or nmm or nmmb

msg="JOB $job FOR WRF NEST=${NEST}${MODEL}_${MEMBER} HAS BEGUN"
postmsg "$jlogfile" "$msg"

yy=`echo $PDY | cut -c1-4`
mm=`echo $PDY | cut -c5-6`
dd=`echo $PDY | cut -c7-8`

ystart=`echo $PDY | cut -c1-4`
mstart=`echo $PDY | cut -c5-6`
dstart=`echo $PDY | cut -c7-8`

start=$ystart$mstart$dstart$cyc

echo start $start

# NDATE=/u/Matthew.Pyle/ndate
NDATE=/nwprod/util/exec/ndate

int1=`$NDATE +12 $start`
yyint1=`echo $int1 | cut -c1-4`
mmint1=`echo $int1 | cut -c5-6`
ddint1=`echo $int1 | cut -c7-8`
hhint1=`echo $int1 | cut -c9-10`

int2=`$NDATE +12 $int1`
yyint2=`echo $int2 | cut -c1-4`
mmint2=`echo $int2 | cut -c5-6`
ddint2=`echo $int2 | cut -c7-8`
hhint2=`echo $int2 | cut -c9-10`

int3=`$NDATE +12 $int2`
yyint3=`echo $int3 | cut -c1-4`
mmint3=`echo $int3 | cut -c5-6`
ddint3=`echo $int3 | cut -c7-8`
hhint3=`echo $int3 | cut -c9-10`

int4=`$NDATE +12 $int3`
yyint4=`echo $int4 | cut -c1-4`
mmint4=`echo $int4 | cut -c5-6`
ddint4=`echo $int4 | cut -c7-8`
hhint4=`echo $int4 | cut -c9-10`

echo $int1 $int2 $int3 $int4

end=`$NDATE $LENGTH $start`

echo end $end

yend=`echo $end | cut -c1-4`
mend=`echo $end | cut -c5-6`
dend=`echo $end | cut -c7-8`

whr=00
count=0
last=$LENGTH
incr=3

#
# Check to see how many storms are being run by the GFDL hurricane model.
# If number is >= 2, do not make any hiresw runs.
# If number is 1, cancel job if this is a WRF-EM run.
#
#if [ "$NEST" != "pr" -a "$NEST" != "hi" -a "$NEST" != "guam" ] ; then
  $USHhiresw/hiresw_chkhur.sh $MODEL
  err=$?
  if [ $err -eq 99 ] ; then
    exit
  fi
  echo "export NEST=$NEST" > $COMOUT/${RUN}.t${cyc}z.envir.sh
  echo "export MODEL=$MODEL" >> $COMOUT/${RUN}.t${cyc}z.envir.sh
#fi

export CYCLE=$PDY$cyc
echo "export CYCLE=$CYCLE" >> $COMOUT/${RUN}.t${cyc}z.envir.sh

# All domains : Use GFS (0.5 degree pgrb2)
# CONUS : Also Use RAP (grid 221)

export DATA

mkdir -p $DATA/run_ungrib
mkdir -p $DATA/run_ungrib_1
mkdir -p $DATA/run_ungrib_2
mkdir -p $DATA/run_ungrib_3
mkdir -p $DATA/run_ungrib_4


while [ $whr -le $last ]
do

# elif [ $NEST = "conus" -a $MODEL = "arw" ]
# then

#  cp ${COMRAP}/rap.t${cyc}z.awip32f${whr} $DATA/run_ungrib/.
#  cp $PARMhiresw/hiresw_Vtable.RAP $DATA/run_ungrib/Vtable
#  err1=$?
#  mod=rap
# type=awip32f	
# suf=""


  cp ${COMGFS}/gfs.t${cyc}z.pgrb2f${whr} $DATA/.
  err1=$?
  cp $PARMhiresw/hiresw_Vtable.GFS  $DATA/run_ungrib_1/Vtable 
  cp $PARMhiresw/hiresw_Vtable.GFS  $DATA/run_ungrib_2/Vtable 
  cp $PARMhiresw/hiresw_Vtable.GFS  $DATA/run_ungrib_3/Vtable 
  cp $PARMhiresw/hiresw_Vtable.GFS  $DATA/run_ungrib_4/Vtable 
  mod=gfs
  type=pgrb2f
  suf=""

if [ $mod = "rap" ]
then
GRIBSRC=RAP
elif [ $mod = "gfs" ]
then
GRIBSRC=GFS
elif [ $mod = "nam" ]
then
GRIBSRC=NAM
fi


if [ $MODEL != "nmmb" ]
then

  cat $PARMhiresw/hiresw_${NEST}_${MODEL}.namelist.wps_in_new | sed s:YSTART:$ystart: | sed s:MSTART:$mstart: \
 | sed s:DSTART:$dstart: | sed s:HSTART:$cyc: | sed s:YEND:$yyint1: \
 | sed s:MEND:$mmint1:     | sed s:DEND:$ddint1: | sed s:HEND:$hhint1: > $DATA/namelist.wps.1

  cat $PARMhiresw/hiresw_${NEST}_${MODEL}.namelist.wps_in_new | sed s:YSTART:$yyint1: | sed s:MSTART:$mmint1: \
 | sed s:DSTART:$ddint1: | sed s:HSTART:$hhint1: | sed s:YEND:$yyint2: \
 | sed s:MEND:$mmint2:     | sed s:DEND:$ddint2: | sed s:HEND:$hhint2: > $DATA/namelist.wps.2

  cat $PARMhiresw/hiresw_${NEST}_${MODEL}.namelist.wps_in_new | sed s:YSTART:$yyint2: | sed s:MSTART:$mmint2: \
 | sed s:DSTART:$ddint2: | sed s:HSTART:$hhint2: | sed s:YEND:$yyint3: \
 | sed s:MEND:$mmint3:     | sed s:DEND:$ddint3: | sed s:HEND:$hhint3: > $DATA/namelist.wps.3

  cat $PARMhiresw/hiresw_${NEST}_${MODEL}.namelist.wps_in_new | sed s:YSTART:$yyint3: | sed s:MSTART:$mmint3: \
 | sed s:DSTART:$ddint3: | sed s:HSTART:$hhint3: | sed s:YEND:$yyint4: \
 | sed s:MEND:$mmint4:     | sed s:DEND:$ddint4: | sed s:HEND:$hhint4: > $DATA/namelist.wps.4

else

  cat $PARMhiresw/hiresw_${NEST}_${MODEL}.namelist.nps_in | sed s:YSTART:$ystart: | sed s:MSTART:$mstart: \
 | sed s:DSTART:$dstart: | sed s:HSTART:$cyc: | sed s:YEND:$yyint1: \
 | sed s:MEND:$mmint1:     | sed s:DEND:$ddint1: | sed s:HEND:$hhint1: | sed s:_GRIBSRC_:${GRIBSRC}:g > $DATA/namelist.nps.1

  cat $PARMhiresw/hiresw_${NEST}_${MODEL}.namelist.nps_in | sed s:YSTART:$yyint1: | sed s:MSTART:$mmint1: \
 | sed s:DSTART:$ddint1: | sed s:HSTART:$hhint1: | sed s:YEND:$yyint2: \
 | sed s:MEND:$mmint2:     | sed s:DEND:$ddint2: | sed s:HEND:$hhint2: | sed s:_GRIBSRC_:${GRIBSRC}:g > $DATA/namelist.nps.2

  cat $PARMhiresw/hiresw_${NEST}_${MODEL}.namelist.nps_in | sed s:YSTART:$yyint2: | sed s:MSTART:$mmint2: \
 | sed s:DSTART:$ddint2: | sed s:HSTART:$hhint2: | sed s:YEND:$yyint3: \
 | sed s:MEND:$mmint3:     | sed s:DEND:$ddint3: | sed s:HEND:$hhint3: | sed s:_GRIBSRC_:${GRIBSRC}:g > $DATA/namelist.nps.3

  cat $PARMhiresw/hiresw_${NEST}_${MODEL}.namelist.nps_in | sed s:YSTART:$yyint3: | sed s:MSTART:$mmint3: \
 | sed s:DSTART:$ddint3: | sed s:HSTART:$hhint3: | sed s:YEND:$yyint4: \
 | sed s:MEND:$mmint4:     | sed s:DEND:$ddint4: | sed s:HEND:$hhint4: | sed s:_GRIBSRC_:${GRIBSRC}:g > $DATA/namelist.nps.4

fi





if [ $err1 -ne 0 ] 
then
  ./err_exit "$whr input GRIB file from $GRIBSRC not found.  FATAL ERROR"
fi

whr=`expr $whr + $incr`

if [ $whr -lt 10 ]
then
whr=0$whr
fi

done

# cd $DATA/run_ungrib

if [ $GRIBSRC != "RAP" ]
then

mv ${mod}.t${cyc}z.${type}00${suf} ./run_ungrib_1/GRIBFILE.AAA
mv ${mod}.t${cyc}z.${type}03${suf} ./run_ungrib_1/GRIBFILE.AAB
mv ${mod}.t${cyc}z.${type}06${suf} ./run_ungrib_1/GRIBFILE.AAC
mv ${mod}.t${cyc}z.${type}09${suf} ./run_ungrib_1/GRIBFILE.AAD
cp ${mod}.t${cyc}z.${type}12${suf} ./run_ungrib_1/GRIBFILE.AAE

mv ${mod}.t${cyc}z.${type}12${suf} ./run_ungrib_2/GRIBFILE.AAA
mv ${mod}.t${cyc}z.${type}15${suf} ./run_ungrib_2/GRIBFILE.AAB
mv ${mod}.t${cyc}z.${type}18${suf} ./run_ungrib_2/GRIBFILE.AAC
mv ${mod}.t${cyc}z.${type}21${suf} ./run_ungrib_2/GRIBFILE.AAD
cp ${mod}.t${cyc}z.${type}24${suf} ./run_ungrib_2/GRIBFILE.AAE

mv ${mod}.t${cyc}z.${type}24${suf} ./run_ungrib_3/GRIBFILE.AAA
mv ${mod}.t${cyc}z.${type}27${suf} ./run_ungrib_3/GRIBFILE.AAB
mv ${mod}.t${cyc}z.${type}30${suf} ./run_ungrib_3/GRIBFILE.AAC
mv ${mod}.t${cyc}z.${type}33${suf} ./run_ungrib_3/GRIBFILE.AAD
cp ${mod}.t${cyc}z.${type}36${suf} ./run_ungrib_3/GRIBFILE.AAE

mv ${mod}.t${cyc}z.${type}36${suf} ./run_ungrib_4/GRIBFILE.AAA
mv ${mod}.t${cyc}z.${type}39${suf} ./run_ungrib_4/GRIBFILE.AAB
mv ${mod}.t${cyc}z.${type}42${suf} ./run_ungrib_4/GRIBFILE.AAC
mv ${mod}.t${cyc}z.${type}45${suf} ./run_ungrib_4/GRIBFILE.AAD
mv ${mod}.t${cyc}z.${type}48${suf} ./run_ungrib_4/GRIBFILE.AAE

else

mv ${mod}.t${cyc}z.${type}00${suf} GRIBFILE.AAA
mv ${mod}.t${cyc}z.${type}03${suf} GRIBFILE.AAB

fi


pwd

### run_ungrib

cd $DATA

if [ $MODEL != "nmmb" ]
then
cp $EXEChiresw/hiresw_ungrib_new ungrib.exe
else
cp $EXEChiresw/hiresw_nps_ungrib ungrib.exe
fi

rm -rf poescript


echo "$USHhiresw/hiresw_wps_ungrib_gen.sh $NEST $MODEL $cyc $envir 2"  > poescript
echo "$USHhiresw/hiresw_wps_ungrib_gen.sh $NEST $MODEL $cyc $envir 1" >> poescript
echo "$USHhiresw/hiresw_wps_ungrib_gen.sh $NEST $MODEL $cyc $envir 3" >> poescript
echo "$USHhiresw/hiresw_wps_ungrib_gen.sh $NEST $MODEL $cyc $envir 4" >> poescript

chmod 775 $DATA/poescript
export MP_PGMMODEL=mpmd
export MP_CMDFILE=poescript
export MP_LABELIO=YES
export MP_INFOLEVEL=3
export MP_STDOUTMODE=ordered

mpirun.lsf
err=$?
echo "err from ungrib poe job: " $err

ls FILE*


# ic=0

# while [ $ic -lt 1000 ] ; do

#  icntb=1
#  itest=1
#  while [ $icntb -le 4 ] ; do
#   ls -l $DATA/ungribdone.$icntb
#   err1=$?
#   if [ $err1 -eq 0 ] ; then
#    let "itest=itest+1"
#   fi
#   let "icntb=icntb+1"
#  done

#  if [ $itest -eq 10 ] ; then
#    break
#  else
#    let "ic=ic+1"
#    sleep 10
#  fi

#  if [ $ic -ge 1000 ] ; then
#   exit 1
# fi

# done



# cd $DATA/run_ungrib/

# if [ $MODEL != "nmmb" ]
# then
# cp $EXEChiresw/hiresw_ungrib_new ungrib.exe

# ./ungrib.exe >> $pgmout 2>errfile
# else
# cp $EXEChiresw/hiresw_nps_ungrib ungrib.exe
# mpirun.lsf ./ungrib.exe
# fi


msg="JOB $job FOR WRF NEST=${NEST}${MODEL}_${MEMBER} HAS COMPLETED NORMALLY"
postmsg "$jlogfile" "$msg"
